interface XiorRequestConfig<T = any> extends Omit<RequestInit, 'body'> {
    /** fetch?: @type Fetch  */
    fetch?: (input: any, init?: any) => Promise<any>;
    url?: string;
    headers?: Record<string, any>;
    baseURL?: string;
    params?: Record<string, any>;
    /** If no set, default depends on browsers timeout */
    timeout?: number;
    paramsSerializer?: (params: Record<string, any>) => string;
    /** Use encodeURIComponent, default: true */
    encodeURI?: boolean;
    /**
     * Currently only support 'json' | 'text', default: 'json';
     * Others will just return the original response
     */
    responseType?: 'json' | 'text' | 'stream' | 'document' | 'arraybuffer' | 'blob' | 'original' | 'custom';
    data?: any;
    /**
     * @deprecated Internal use only
     * encoded url with params
     */
    _url?: string;
    /** @deprecated if `true`, will set `credentials=true`, or you can just use fetch's config `credentials: 'include' | 'omit' | 'same-origin'` */
    withCredentials?: boolean;
    /**
     * some API is get data, but the method is not 'GET',
     * add `isGet: true`, can let the plugins know this is also a `GET` API
     */
    isGet?: boolean;
    /**
     * @deprecated Internal use only
     * response interceptors already run?
     */
    _did?: boolean;
}
type XiorInterceptorRequestConfig<T = any> = XiorRequestConfig & {
    headers: Record<string, any>;
    params: Record<string, any>;
    url: string;
    method: string;
};
interface XiorResponse<T = any> {
    data: T;
    status: number;
    statusText: string;
    headers: Headers;
    response: Response;
    config: XiorInterceptorRequestConfig;
    request?: any;
}
type XiorPlugin = (adapter: (request: XiorRequestConfig) => Promise<XiorResponse>, instance?: XiorInstance) => (request: XiorRequestConfig) => Promise<XiorResponse<any>>;
interface XiorInterceptorOptions {
    /** @deprecated useless here */
    synchronous?: boolean;
    /** @deprecated useless here */
    runWhen?: (config: XiorInterceptorRequestConfig) => boolean;
}
interface XiorResponseInterceptorConfig<T = any> {
    data: T;
    config: XiorInterceptorRequestConfig<T>;
    request: XiorInterceptorRequestConfig<T>;
    response: Response;
    status: number;
    statusText: string;
    headers: Headers;
}

/** Code Ref: https://github.com/jacobheun/any-signal/pull/40/files */
interface ClearableSignal extends AbortSignal {
    clear: () => void;
}
/**
 * Takes an array of AbortSignals and returns a single signal.
 * If any signals are aborted, the returned signal will be aborted.
 */
declare function anySignal(signals: (AbortSignal | undefined | null)[], cleanCb?: Function): ClearableSignal;

/** From @voodoocreation/ts-deepmerge: https://github.com/voodoocreation/ts-deepmerge/blob/master/src/index.ts */
type TAllKeys<T> = T extends any ? keyof T : never;
type TIndexValue<T, K extends PropertyKey, D = never> = T extends any ? K extends keyof T ? T[K] : D : never;
type TPartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>> extends infer O ? {
    [P in keyof O]: O[P];
} : never;
type TFunction = (...a: any[]) => any;
type TPrimitives = string | number | boolean | bigint | symbol | Date | TFunction;
type TMerged<T> = [T] extends [any[]] ? {
    [K in keyof T]: TMerged<T[K]>;
} : [T] extends [TPrimitives] ? T : [T] extends [object] ? TPartialKeys<{
    [K in TAllKeys<T>]: TMerged<TIndexValue<T, K>>;
}, never> : T;
interface IObject {
    [key: string]: any;
}
declare const merge: <T extends IObject[]>(...objects: T) => TMerged<T[number]>;

declare function buildSortedURL(url: string, data: Record<string, any> | null, paramsSerializer: (obj: Record<string, any>) => string): string;

declare function delay(ms: number): Promise<unknown>;
type ICacheLike<T> = {
    get(key: string): T | undefined;
    set(key: string, value: T): void;
} & ({
    del(key: string): void;
} | {
    delete(key: string): void;
});

declare function encodeParams<T = any>(params: T, encodeURI?: boolean, parentKey?: string | null, options?: {
    allowDots?: boolean;
    serializeDate?: (value: Date) => string;
    arrayFormat?: 'indices' | 'repeat' | 'brackets';
}): string;
declare function trimUndefined(obj: any): any;
/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
declare function isAbsoluteURL(url: string): boolean;
/**
 * joinPath('/', '/') -> '/'
 * joinPath('/a/', '/b') -> '/a/b'
 * joinPath('/a', '/b') -> '/a/b'
 */
declare function joinPath(path1?: string, path2?: string): string;
declare class XiorError<T = any> extends Error {
    request?: XiorRequestConfig;
    config?: XiorRequestConfig;
    response?: XiorResponse<T>;
    constructor(message: string, request?: XiorRequestConfig, response?: XiorResponse<T>);
}
declare class XiorTimeoutError<T = any> extends XiorError<T> {
    constructor(message: string, request?: XiorRequestConfig, response?: XiorResponse<T>);
}
declare function isXiorError(error: any): boolean;

type XiorInstance = Xior;
type Fetch = typeof fetch;
declare class Xior {
    static create: (options?: XiorRequestConfig) => XiorInstance;
    static VERSION: string;
    config?: XiorRequestConfig;
    defaults: XiorInterceptorRequestConfig;
    constructor(options?: XiorRequestConfig);
    /** request interceptors */
    REQI: ((config: XiorInterceptorRequestConfig) => Promise<XiorInterceptorRequestConfig> | XiorInterceptorRequestConfig)[];
    /** response interceptors */
    RESI: {
        fn: (config: XiorResponseInterceptorConfig) => Promise<XiorResponseInterceptorConfig> | XiorResponseInterceptorConfig;
        /** error: XiorError | Error | TypeError */
        onRejected?: null | ((error: XiorError) => any);
    }[];
    get interceptors(): {
        request: {
            use: (fn: (requestConfig: XiorInterceptorRequestConfig) => Promise<XiorInterceptorRequestConfig> | XiorInterceptorRequestConfig, onRejected?: null | ((error: any) => any), options?: XiorInterceptorOptions) => (requestConfig: XiorInterceptorRequestConfig) => Promise<XiorInterceptorRequestConfig> | XiorInterceptorRequestConfig;
            eject: (fn: (responseWithConfig: XiorInterceptorRequestConfig) => Promise<XiorInterceptorRequestConfig> | XiorInterceptorRequestConfig) => void;
            clear: () => void;
        };
        response: {
            use: (fn: (config: XiorResponseInterceptorConfig) => Promise<XiorResponseInterceptorConfig> | XiorResponseInterceptorConfig, onRejected?: null | ((error: XiorError) => any)) => (config: XiorResponseInterceptorConfig) => Promise<XiorResponseInterceptorConfig> | XiorResponseInterceptorConfig;
            eject: (fn: (config: XiorResponseInterceptorConfig) => Promise<XiorResponseInterceptorConfig> | XiorResponseInterceptorConfig) => void;
            clear: () => void;
        };
    };
    /** plugins */
    P: XiorPlugin[];
    get plugins(): {
        use: (plugin: XiorPlugin) => XiorPlugin;
        eject: (plugin: XiorPlugin) => void;
        clear: () => void;
    };
    request<T>(options: XiorRequestConfig | string): Promise<XiorResponse<T>>;
    /** @deprecated for internal use only */
    _<T>(requestConfig: XiorRequestConfig): Promise<XiorResponse<T>>;
    /** create get like method */
    cG<T>(method: string): (url: string, options?: XiorRequestConfig) => Promise<XiorResponse<T>>;
    /** create post like method */
    cP<T>(method: string): (url: string, data?: any, options?: XiorRequestConfig) => Promise<XiorResponse<T>>;
    get<T = any>(url: string, options?: XiorRequestConfig & {
        /** @deprecated No `data` in `GET` method */
        data?: any;
    }): Promise<XiorResponse<T>>;
    head<T = any>(url: string, options?: XiorRequestConfig & {
        /** @deprecated No `data` in `HEAD` method */
        data?: any;
    }): Promise<XiorResponse<T>>;
    post<T = any>(url: string, data?: any, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    put<T = any>(url: string, data?: any, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    patch<T = any>(url: string, data?: any, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    delete<T = any>(url: string, options?: XiorRequestConfig): Promise<XiorResponse<T>>;
    options<T = any>(url: string, options?: XiorRequestConfig & {
        /** @deprecated No `data` in `OPTIONS` method */
        data?: any;
    }): Promise<XiorResponse<T>>;
}

export { ClearableSignal as C, Fetch as F, ICacheLike as I, Xior as X, XiorRequestConfig as a, XiorInstance as b, XiorInterceptorRequestConfig as c, XiorResponse as d, XiorPlugin as e, XiorInterceptorOptions as f, XiorResponseInterceptorConfig as g, encodeParams as h, isAbsoluteURL as i, joinPath as j, XiorError as k, XiorTimeoutError as l, isXiorError as m, anySignal as n, merge as o, buildSortedURL as p, delay as q, trimUndefined as t };
