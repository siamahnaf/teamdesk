import { a as XiorRequestConfig, b as XiorInstance, c as XiorInterceptorRequestConfig } from '../xior-D4BXsC0R.js';

interface AsymmetricMatcher {
    asymmetricMatch: (payload: any) => any;
}
type RequestOptions = XiorRequestConfig & {
    headers?: AsymmetricMatcher | Record<string, string>;
    params?: AsymmetricMatcher | Record<string, any>;
    data?: AsymmetricMatcher | Record<string, any>;
};
type RequestData<T> = null | string | boolean | any[] | number | AsymmetricMatcher | Record<string, any>;
type MockHeaders = Record<string, any>;
type StatusOrCallback = number | ((config: XiorRequestConfig) => any | any[] | Promise<any[]>);

interface MockOptions {
    delayResponse?: number;
    onNoMatch?: 'passthrough' | 'throwException';
}
declare class MockError extends Error {
    request?: XiorRequestConfig;
    config?: XiorInterceptorRequestConfig<any>;
    constructor(message: string, request?: XiorInterceptorRequestConfig<any>);
}
declare class MockPlugin {
    private options;
    private instance;
    private plugin;
    constructor(xiorInstance: XiorInstance, options?: MockOptions);
    handlers: {
        [method: string]: undefined | any[];
    };
    history: {
        [method: string]: undefined | XiorRequestConfig<any>[];
    };
    private _mockPlugin;
    resetHandlers(): void;
    resetHistory(): void;
    reset(): void;
    restore(): void;
    onGet<T extends any>(matcher?: string | RegExp, options?: RequestOptions): ReturnType<ReturnType<typeof this.createHandler>>;
    onDelete<T extends any>(matcher?: string | RegExp, options?: RequestOptions): ReturnType<ReturnType<typeof this.createHandler>>;
    onHead<T extends any>(matcher?: string | RegExp, options?: RequestOptions): ReturnType<ReturnType<typeof this.createHandler>>;
    onAny<T extends any>(matcher?: string | RegExp, options?: RequestOptions): ReturnType<ReturnType<typeof this.createHandler>>;
    onPost<T extends any>(matcher?: string | RegExp, data?: RequestData<T>, options?: RequestOptions): ReturnType<ReturnType<typeof this.createHandler>>;
    onPut<T extends any>(matcher?: string | RegExp, data?: RequestData<T>, options?: RequestOptions): ReturnType<ReturnType<typeof this.createHandler>>;
    onPatch<T extends any>(matcher?: string | RegExp, data?: RequestData<T>, options?: RequestOptions): ReturnType<ReturnType<typeof this.createHandler>>;
    onOptions<T extends any>(matcher?: string | RegExp, options?: RequestOptions): ReturnType<ReturnType<typeof this.createHandler>>;
    createHandler(method: string): (matcher?: string | RegExp, options?: XiorRequestConfig) => {
        reply: (code: StatusOrCallback, responseData?: any, responseHeaders?: MockHeaders) => MockPlugin;
        replyOnce: (code: StatusOrCallback, responseData?: any, responseHeaders?: MockHeaders) => MockPlugin;
        withDelayInMs: (delay: number) => (code: StatusOrCallback, responseData?: any, responseHeaders?: MockHeaders) => MockPlugin;
        passThrough: () => MockPlugin;
        abortRequest(): MockPlugin;
        abortRequestOnce(): MockPlugin;
        networkError(): MockPlugin;
        networkErrorOnce(): MockPlugin;
        timeout(): MockPlugin;
        timeoutOnce(): MockPlugin;
    };
    addHandler(method: string, _handler: any[]): void;
    findHandler(config: XiorRequestConfig): any;
}

export { MockError, MockOptions, MockPlugin as default };
